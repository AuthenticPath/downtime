<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Downtime App Demo</title>
  <style>
    /* Reset & Global Styles */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #f0f4f8;
      color: #333;
      line-height: 1.6;
    }
    header {
      background: linear-gradient(135deg, #6a11cb, #2575fc);
      color: #fff;
      padding: 20px;
      text-align: center;
      margin-bottom: 20px;
    }
    header h1 {
      font-size: 2em;
    }
    #container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px 40px;
    }
    /* User Cards */
    #user-network {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      margin-bottom: 30px;
    }
    .user-card {
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      padding: 15px;
      width: 260px;
      transition: transform 0.3s;
    }
    .user-card:hover {
      transform: translateY(-5px);
    }
    .user-card.available {
      border-left: 5px solid #28a745;
    }
    .user-card.unavailable {
      border-left: 5px solid #ccc;
      opacity: 0.8;
    }
    .user-card h3 {
      margin-bottom: 10px;
      font-size: 1.2em;
    }
    .control-group {
      margin-bottom: 10px;
    }
    label {
      display: block;
      font-size: 0.9em;
      margin-bottom: 5px;
    }
    select, input[type="checkbox"] {
      margin-right: 5px;
      margin-bottom: 5px;
    }
    .willing-tiers,
    .block-users {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }
    /* Chat Buttons */
    #chat-buttons {
      text-align: center;
      margin-bottom: 30px;
    }
    #chat-buttons button {
      margin: 5px;
      padding: 10px 20px;
      font-size: 1em;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: background 0.3s;
    }
    #one-on-one-btn {
      background: #28a745;
      color: #fff;
    }
    #group-chat-btn {
      background: #007bff;
      color: #fff;
    }
    #one-on-one-btn:hover {
      background: #218838;
    }
    #group-chat-btn:hover {
      background: #0069d9;
    }
    /* Chat Options Panel */
    #chat-options-panel, #invite-panel {
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      padding: 15px;
      max-width: 600px;
      margin: 0 auto 30px;
    }
    #chat-options-panel h3,
    #invite-panel h3 {
      margin-bottom: 10px;
    }
    #chat-options-panel p {
      margin-bottom: 15px;
    }
    #chat-options-panel button,
    #invite-panel button {
      margin: 5px;
      padding: 8px 16px;
      font-size: 0.9em;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.3s;
    }
    #upgrade-btn {
      background: #ffc107;
      color: #333;
    }
    #upgrade-btn:hover {
      background: #e0a800;
    }
    #invite-btn {
      background: #17a2b8;
      color: #fff;
    }
    #invite-btn:hover {
      background: #138496;
    }
    #end-chat-btn {
      background: #dc3545;
      color: #fff;
    }
    #end-chat-btn:hover {
      background: #c82333;
    }
    /* Invite Panel */
    #invite-panel div {
      margin-bottom: 8px;
    }
    /* Notifications */
    #notifications {
      max-width: 600px;
      margin: 0 auto;
    }
    .notification {
      background: #fff;
      border-left: 5px solid #007bff;
      padding: 10px 15px;
      margin-bottom: 10px;
      border-radius: 5px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
  </style>
</head>
<body>
  <header>
    <h1>Downtime App Demo</h1>
  </header>
  <div id="container">
    <div id="user-network"></div>
    <div id="chat-buttons">
      <button id="one-on-one-btn">Start 1‑on‑1 Chat</button>
      <button id="group-chat-btn">Initiate Group Chat</button>
    </div>
    <div id="chat-options-panel" style="display:none;"></div>
    <div id="invite-panel" style="display:none;"></div>
    <div id="notifications"></div>
  </div>

  <script>
    /**********************************************************************
     * Downtime App Rules & Logic (Enhanced Demo)
     *
     * Core features:
     * 1. User Network: 7 sample users with name, availability toggle, tier 
     *    assignment, connection preferences (which tiers they want to connect 
     *    with), and an option to block specific users.
     *
     * 2. Chat Options: Choose either 1‑on‑1 or group chat.
     *
     * 3. Once a 1‑on‑1 chat connects, a panel appears offering:
     *     - Upgrade to Group Chat (automatically adds additional users
     *       meeting allowed tier & connection preferences)
     *     - Invite Specific People (manually choose among available users)
     *
     * 4. Matching now factors in:
     *     - Tier values (and allowed threshold from the initial connection)
     *     - Each user’s “willing to connect with” preferences
     *     - Block lists (if either party has blocked the other, connection is blocked)
     *
     * 5. After a chat connection, participants are marked unavailable.
     **********************************************************************/

    // Sample users (each now has connection preferences and a block list)
    const users = [
      { id: 1, name: 'Alice', available: false, tier: 'Tier 1', willingTiers: ["Tier 1", "Tier 2", "Tier 3"], blockedUsers: [] },
      { id: 2, name: 'Bob', available: false, tier: 'Tier 2', willingTiers: ["Tier 1", "Tier 2", "Tier 3"], blockedUsers: [] },
      { id: 3, name: 'Charlie', available: false, tier: 'Tier 3', willingTiers: ["Tier 1", "Tier 2", "Tier 3"], blockedUsers: [] },
      { id: 4, name: 'Diana', available: false, tier: 'Tier 1', willingTiers: ["Tier 1", "Tier 2", "Tier 3"], blockedUsers: [] },
      { id: 5, name: 'Ethan', available: false, tier: 'Tier 2', willingTiers: ["Tier 1", "Tier 2", "Tier 3"], blockedUsers: [] },
      { id: 6, name: 'Fiona', available: false, tier: 'Tier 3', willingTiers: ["Tier 1", "Tier 2", "Tier 3"], blockedUsers: [] },
      { id: 7, name: 'George', available: false, tier: 'Tier 1', willingTiers: ["Tier 1", "Tier 2", "Tier 3"], blockedUsers: [] }
    ];

    // Tier values for matching (Blocked tier remains separate)
    const tierValues = {
      "Tier 1": 1,
      "Tier 2": 2,
      "Tier 3": 3,
      "Blocked": Infinity
    };

    // Global chat state: currentChat = { type, participants, allowedTierValue }
    let currentChat = null;

    // DOM Elements
    const userNetworkEl = document.getElementById('user-network');
    const notificationsEl = document.getElementById('notifications');
    const oneOnOneBtn = document.getElementById('one-on-one-btn');
    const groupChatBtn = document.getElementById('group-chat-btn');
    const chatOptionsPanel = document.getElementById('chat-options-panel');
    const invitePanel = document.getElementById('invite-panel');

    // Helper: Check if two users can connect based on their preferences and block lists.
    function canConnect(userA, userB) {
      // Check connection preferences ("willing to connect with")
      if (!userA.willingTiers.includes(userB.tier)) return false;
      if (!userB.willingTiers.includes(userA.tier)) return false;
      // Check if either user has blocked the other
      if (userA.blockedUsers.includes(userB.id)) return false;
      if (userB.blockedUsers.includes(userA.id)) return false;
      return true;
    }

    // Render user cards with updated controls for connection preferences and block lists.
    function renderUsers() {
      userNetworkEl.innerHTML = "";
      users.forEach(user => {
        const card = document.createElement('div');
        card.classList.add('user-card');
        card.id = `user-${user.id}`;
        card.classList.add(user.available ? 'available' : 'unavailable');

        // Build basic controls: Name, Availability, and Tier Assignment.
        let cardHTML = `
          <h3>${user.name}</h3>
          <div class="control-group">
            <label for="avail-${user.id}">Availability:</label>
            <input type="checkbox" id="avail-${user.id}" ${user.available ? 'checked' : ''}>
          </div>
          <div class="control-group">
            <label for="tier-${user.id}">Tier Assignment:</label>
            <select id="tier-${user.id}">
              <option value="Tier 1" ${user.tier === 'Tier 1' ? 'selected' : ''}>Tier 1</option>
              <option value="Tier 2" ${user.tier === 'Tier 2' ? 'selected' : ''}>Tier 2</option>
              <option value="Tier 3" ${user.tier === 'Tier 3' ? 'selected' : ''}>Tier 3</option>
              <option value="Blocked" ${user.tier === 'Blocked' ? 'selected' : ''}>Blocked</option>
            </select>
          </div>
        `;

        // Add connection preference checkboxes ("Willing to connect with")
        cardHTML += `
          <div class="control-group">
            <label>Willing to connect with:</label>
            <div class="willing-tiers">
              <input type="checkbox" id="willing-${user.id}-Tier1" value="Tier 1" ${user.willingTiers.includes("Tier 1") ? "checked" : ""}>
              <label for="willing-${user.id}-Tier1">Tier 1</label>
              <input type="checkbox" id="willing-${user.id}-Tier2" value="Tier 2" ${user.willingTiers.includes("Tier 2") ? "checked" : ""}>
              <label for="willing-${user.id}-Tier2">Tier 2</label>
              <input type="checkbox" id="willing-${user.id}-Tier3" value="Tier 3" ${user.willingTiers.includes("Tier 3") ? "checked" : ""}>
              <label for="willing-${user.id}-Tier3">Tier 3</label>
            </div>
          </div>
        `;

        // Add controls to block specific users.
        cardHTML += `<div class="control-group">
                       <label>Block Users:</label>
                       <div class="block-users">`;
        // List all other users as possible block options.
        users.forEach(other => {
          if (other.id !== user.id) {
            const checked = user.blockedUsers.includes(other.id) ? "checked" : "";
            cardHTML += `<input type="checkbox" id="block-${user.id}-${other.id}" value="${other.id}" ${checked}>
                         <label for="block-${user.id}-${other.id}">${other.name}</label>`;
          }
        });
        cardHTML += `   </div>
                     </div>`;

        card.innerHTML = cardHTML;
        userNetworkEl.appendChild(card);

        // Event Listener: Availability toggle.
        const availCheckbox = card.querySelector(`#avail-${user.id}`);
        availCheckbox.addEventListener('change', (e) => {
          user.available = e.target.checked;
          updateUserCardStyle(user.id);
        });

        // Event Listener: Tier assignment change.
        const tierSelect = card.querySelector(`#tier-${user.id}`);
        tierSelect.addEventListener('change', (e) => {
          user.tier = e.target.value;
        });

        // Event Listeners for "Willing to connect with" checkboxes.
        const willingCheckboxes = card.querySelectorAll(".willing-tiers input[type='checkbox']");
        willingCheckboxes.forEach(chk => {
          chk.addEventListener('change', (e) => {
            const tierVal = e.target.value;
            if (e.target.checked) {
              if (!user.willingTiers.includes(tierVal)) {
                user.willingTiers.push(tierVal);
              }
            } else {
              user.willingTiers = user.willingTiers.filter(t => t !== tierVal);
            }
          });
        });

        // Event Listeners for "Block Users" checkboxes.
        const blockCheckboxes = card.querySelectorAll(".block-users input[type='checkbox']");
        blockCheckboxes.forEach(chk => {
          chk.addEventListener('change', (e) => {
            const blockedId = parseInt(e.target.value);
            if (e.target.checked) {
              if (!user.blockedUsers.includes(blockedId)) {
                user.blockedUsers.push(blockedId);
              }
            } else {
              user.blockedUsers = user.blockedUsers.filter(id => id !== blockedId);
            }
          });
        });
      });
    }

    // Update visual style for a user card based on availability.
    function updateUserCardStyle(userId) {
      const user = users.find(u => u.id === userId);
      const card = document.getElementById(`user-${userId}`);
      if (user.available) {
        card.classList.remove('unavailable');
        card.classList.add('available');
      } else {
        card.classList.remove('available');
        card.classList.add('unavailable');
      }
    }

    // Helper: Add a notification message.
    function addNotification(message) {
      const note = document.createElement('div');
      note.classList.add('notification');
      note.innerHTML = message;
      notificationsEl.prepend(note);
      setTimeout(() => note.remove(), 5000);
    }

    // Helper: Mark a user (or users) as unavailable.
    function markUserUnavailable(user) {
      user.available = false;
      const checkbox = document.getElementById(`avail-${user.id}`);
      if (checkbox) checkbox.checked = false;
      updateUserCardStyle(user.id);
    }
    function markUsersUnavailable(usersArray) {
      usersArray.forEach(user => markUserUnavailable(user));
    }

    // 1‑on‑1 Chat: Select the first available user and find a connectable partner.
    function startOneOnOneChat() {
      const availableUsers = users.filter(u => u.available && u.tier !== "Blocked");
      if (availableUsers.length < 2) {
        addNotification("No one in your network is available right now. Try again later!");
        return;
      }
      const initial = availableUsers[0];
      const allowedTierValue = tierValues[initial.tier];
      let partner = null;
      for (let i = 1; i < availableUsers.length; i++) {
        const candidate = availableUsers[i];
        if (tierValues[candidate.tier] <= allowedTierValue && canConnect(initial, candidate)) {
          partner = candidate;
          break;
        }
      }
      if (!partner) {
        addNotification("Not enough connectable participants to form a 1‑on‑1 chat.");
        return;
      }
      currentChat = {
        type: "oneOnOne",
        participants: [initial, partner],
        allowedTierValue: allowedTierValue
      };
      markUsersUnavailable([initial, partner]);
      addNotification(`1‑on‑1 Chat connected: ${initial.name} and ${partner.name}`);
      updateChatOptionsPanel();
    }

    // Group Chat: Automatically add all available users meeting allowed tier and connection rules.
    function startGroupChat() {
      const availableUsers = users.filter(u => u.available && u.tier !== "Blocked");
      if (availableUsers.length < 2) {
        addNotification("No one in your network is available right now. Try again later!");
        return;
      }
      const initial = availableUsers[0];
      const allowedTierValue = tierValues[initial.tier];
      const participants = [initial];
      availableUsers.slice(1).forEach(candidate => {
        if (tierValues[candidate.tier] <= allowedTierValue && canConnect(initial, candidate)) {
          participants.push(candidate);
        }
      });
      if (participants.length < 2) {
        addNotification("Not enough connectable participants to form a group chat.");
        return;
      }
      currentChat = {
        type: "group",
        participants: participants,
        allowedTierValue: allowedTierValue
      };
      markUsersUnavailable(participants);
      addNotification(`Group chat connected: ${participants.map(u => u.name).join(", ")}`);
      updateChatOptionsPanel();
    }

    // Display Chat Options Panel (for active chats).
    function updateChatOptionsPanel() {
      if (!currentChat) {
        chatOptionsPanel.style.display = "none";
        return;
      }
      let html = `<h3>Active Chat (${currentChat.type === "oneOnOne" ? "1‑on‑1" : "Group"})</h3>`;
      html += `<p>Participants: ${currentChat.participants.map(u => u.name).join(", ")}</p>`;
      if (currentChat.type === "oneOnOne") {
        html += `<button id="upgrade-btn">Upgrade to Group Chat</button>`;
      }
      html += `<button id="invite-btn">Invite Specific People</button>`;
      html += `<button id="end-chat-btn">End Chat</button>`;
      chatOptionsPanel.innerHTML = html;
      chatOptionsPanel.style.display = "block";

      if (document.getElementById("upgrade-btn")) {
        document.getElementById("upgrade-btn").addEventListener("click", upgradeToGroupChat);
      }
      document.getElementById("invite-btn").addEventListener("click", showInvitePanel);
      document.getElementById("end-chat-btn").addEventListener("click", endChat);
    }

    // Upgrade a 1‑on‑1 chat to a group chat by adding additional available users.
    function upgradeToGroupChat() {
      const availableUsers = users.filter(u => u.available && u.tier !== "Blocked" && 
                                !currentChat.participants.some(p => p.id === u.id));
      const newParticipants = [];
      availableUsers.forEach(candidate => {
        if (tierValues[candidate.tier] <= currentChat.allowedTierValue && canConnect(currentChat.participants[0], candidate)) {
          newParticipants.push(candidate);
        }
      });
      if (newParticipants.length === 0) {
        addNotification("No additional users available to add to the group chat.");
        return;
      }
      newParticipants.forEach(user => {
        currentChat.participants.push(user);
        markUserUnavailable(user);
      });
      currentChat.type = "group";
      addNotification(`Group chat upgraded. Participants: ${currentChat.participants.map(u => u.name).join(", ")}`);
      updateChatOptionsPanel();
    }

    // Show panel to invite specific people (only those available and connectable).
    function showInvitePanel() {
      const availableInvitees = users.filter(u => u.available && u.tier !== "Blocked" && 
                                      !currentChat.participants.some(p => p.id === u.id) &&
                                      canConnect(currentChat.participants[0], u));
      if (availableInvitees.length === 0) {
        addNotification("No additional users available for invitation.");
        return;
      }
      let html = "<h3>Invite Specific People</h3>";
      availableInvitees.forEach(user => {
        html += `<div>
                   <input type="checkbox" id="invite-${user.id}" value="${user.id}">
                   <label for="invite-${user.id}">${user.name} (Tier: ${user.tier})</label>
                 </div>`;
      });
      html += '<button id="send-invites-btn">Send Invites</button>';
      invitePanel.innerHTML = html;
      invitePanel.style.display = "block";

      document.getElementById("send-invites-btn").addEventListener("click", () => {
        const checkboxes = invitePanel.querySelectorAll('input[type="checkbox"]');
        const invitedUsers = [];
        checkboxes.forEach(chk => {
          if (chk.checked) {
            const userId = parseInt(chk.value);
            const user = users.find(u => u.id === userId);
            if (user) {
              invitedUsers.push(user);
            }
          }
        });
        let successInvites = [];
        let failedInvites = [];
        invitedUsers.forEach(user => {
          if (tierValues[user.tier] <= currentChat.allowedTierValue && canConnect(currentChat.participants[0], user)) {
            currentChat.participants.push(user);
            markUserUnavailable(user);
            successInvites.push(user.name);
          } else {
            failedInvites.push(user.name);
          }
        });
        if (successInvites.length > 0) {
          addNotification(`Invited: ${successInvites.join(", ")}`);
        }
        if (failedInvites.length > 0) {
          addNotification(`Could not invite (preferences/tier restrictions): ${failedInvites.join(", ")}`);
        }
        invitePanel.style.display = "none";
        updateChatOptionsPanel();
      });
    }

    // End current chat: mark participants available again and reset the chat state.
    function endChat() {
      if (!currentChat) return;
      currentChat.participants.forEach(user => {
        user.available = true;
        updateUserCardStyle(user.id);
        const checkbox = document.getElementById(`avail-${user.id}`);
        if (checkbox) checkbox.checked = true;
      });
      currentChat = null;
      chatOptionsPanel.style.display = "none";
      addNotification("Chat ended.");
    }

    // Event listeners for chat initiation buttons.
    oneOnOneBtn.addEventListener('click', startOneOnOneChat);
    groupChatBtn.addEventListener('click', startGroupChat);

    // Initial render of user cards.
    renderUsers();
  </script>
</body>
</html>
